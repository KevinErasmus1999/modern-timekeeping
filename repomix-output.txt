This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-27T08:04:19.364Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
client/
  public/
    vite.svg
  src/
    assets/
      react.svg
    components/
      AssignShopDialog.tsx
      EmployeeDialog.tsx
      Layout.tsx
      QuickUploadButton.tsx
    context/
      AuthContext.tsx
    pages/
      Dashboard.tsx
      Employees.tsx
      Login.tsx
      Reports.tsx
      Settings.tsx
      Shops.tsx
      TimeEntries.tsx
    routes/
      index.tsx
    utils/
      api.ts
    App.css
    App.tsx
    index.css
    main.tsx
    vite-env.d.ts
  .gitignore
  eslint.config.js
  index.html
  package.json
  README.md
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
server/
  src/
    entities/
      Employee.ts
      Entity.ts
      Settings.ts
      Shop.ts
      TimeEntry.ts
      User.ts
    middleware/
      auth.ts
      errorHandler.ts
    migrations/
      UpdateEmployeeSchema.ts
    routes/
      auth.ts
      dashboard.ts
      employees.ts
      reports.ts
      settings.ts
      shops.ts
      timeEntries.ts
    types/
      express/
        index.d.ts
      custom.d.ts
    app.ts
    config.ts
    data-source.ts
    database.ts
  package.json
  tsconfig.json
  typeorm.config.ts
.gitignore

================================================================
Repository Files
================================================================

================
File: client/public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: client/src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: client/src/components/AssignShopDialog.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert
} from '@mui/material';

interface Shop {
  id: number;
  name: string;
}

interface AssignShopDialogProps {
  open: boolean;
  onClose: () => void;
  employeeId: number;
  currentShopId?: number;
  onAssigned?: () => void;
}

export default function AssignShopDialog({
  open,
  onClose,
  employeeId,
  currentShopId,
  onAssigned
}: AssignShopDialogProps) {
  const [shops, setShops] = useState<Shop[]>([]);
  const [selectedShop, setSelectedShop] = useState<number>(currentShopId || 0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (open) {
      fetchShops();
      setSelectedShop(currentShopId || 0);
    }
  }, [open, currentShopId]);

  const fetchShops = async () => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch('/api/shops', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) throw new Error('Failed to fetch shops');

      const data = await response.json();
      setShops(data);
    } catch (error) {
      setError('Failed to fetch shops');
    }
  };

  const handleAssign = async () => {
    try {
      setLoading(true);
      setError(null);

      const token = localStorage.getItem('token');
      const response = await fetch(`/api/employees/${employeeId}/assign-shop`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ shopId: selectedShop || null })
      });

      if (!response.ok) {
        throw new Error('Failed to assign shop');
      }

      if (onAssigned) {
        await onAssigned();
      }
      onClose();
    } catch (error) {
      setError('Failed to assign shop');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>Assign to Shop</DialogTitle>
      <DialogContent>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        <FormControl fullWidth sx={{ mt: 2 }}>
          <InputLabel>Select Shop</InputLabel>
          <Select
            value={selectedShop}
            label="Select Shop"
            onChange={(e) => setSelectedShop(Number(e.target.value))}
          >
            <MenuItem value={0}>No Shop</MenuItem>
            {shops.map((shop) => (
              <MenuItem key={shop.id} value={shop.id}>
                {shop.name}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose} disabled={loading}>
          Cancel
        </Button>
        <Button
          onClick={handleAssign}
          variant="contained"
          disabled={loading}
        >
          {loading ? 'Assigning...' : 'Assign'}
        </Button>
      </DialogActions>
    </Dialog>
  );
}

================
File: client/src/components/EmployeeDialog.tsx
================
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  Box,
  ToggleButtonGroup,
  ToggleButton,
  FormControlLabel,
  Switch,
  Grid,
  Typography,
} from '@mui/material';
import { Male, Female } from '@mui/icons-material';

interface EmployeeDialogProps {
  open: boolean;
  onClose: () => void;
  onSubmit: (formData: EmployeeFormData) => void;
  initialData?: EmployeeFormData;
  isEditing?: boolean;
}

export interface EmployeeFormData {
  name: string;
  surname: string;
  email: string;
  cellNumber: string;
  idNumber: string;
  gender: 'male' | 'female';
  hourlyRate: number;
  isActive: boolean;
}

const initialFormData: EmployeeFormData = {
  name: '',
  surname: '',
  email: '',
  cellNumber: '',
  idNumber: '',
  gender: 'male',
  hourlyRate: 0,
  isActive: true,
};

export default function EmployeeDialog({
  open,
  onClose,
  onSubmit,
  initialData,
  isEditing = false
}: EmployeeDialogProps) {
  const [formData, setFormData] = useState<EmployeeFormData>(initialData || initialFormData);
  const [errors, setErrors] = useState<Record<string, string>>({});

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.name.trim()) newErrors.name = 'Name is required';
    if (!formData.surname.trim()) newErrors.surname = 'Surname is required';
    if (!formData.email.trim()) newErrors.email = 'Email is required';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = 'Invalid email format';
    }
    if (!formData.cellNumber.trim()) newErrors.cellNumber = 'Cell number is required';
    if (!/^(\+27|0)\d{9}$/.test(formData.cellNumber)) {
      newErrors.cellNumber = 'Invalid cell number format';
    }
    if (!formData.idNumber.trim()) newErrors.idNumber = 'ID number is required';
    if (!/^\d{13}$/.test(formData.idNumber)) {
      newErrors.idNumber = 'Invalid ID number format';
    }
    if (formData.hourlyRate <= 0) newErrors.hourlyRate = 'Hourly rate must be greater than 0';

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = () => {
    if (validateForm()) {
      onSubmit(formData);
    }
  };

  const handleInputChange = (field: keyof EmployeeFormData) => (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    setFormData(prev => ({
      ...prev,
      [field]: e.target.value
    }));
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
      <DialogTitle>{isEditing ? 'Edit Employee' : 'Add New Employee'}</DialogTitle>
      <DialogContent>
        <Box sx={{ pt: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
          <Grid container spacing={2}>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Name"
                value={formData.name}
                onChange={handleInputChange('name')}
                error={!!errors.name}
                helperText={errors.name}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Surname"
                value={formData.surname}
                onChange={handleInputChange('surname')}
                error={!!errors.surname}
                helperText={errors.surname}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Email"
                type="email"
                value={formData.email}
                onChange={handleInputChange('email')}
                error={!!errors.email}
                helperText={errors.email}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Cell Number"
                value={formData.cellNumber}
                onChange={handleInputChange('cellNumber')}
                error={!!errors.cellNumber}
                helperText={errors.cellNumber}
                placeholder="0123456789"
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="ID Number"
                value={formData.idNumber}
                onChange={handleInputChange('idNumber')}
                error={!!errors.idNumber}
                helperText={errors.idNumber}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Hourly Rate (ZAR)"
                type="number"
                value={formData.hourlyRate}
                onChange={handleInputChange('hourlyRate')}
                error={!!errors.hourlyRate}
                helperText={errors.hourlyRate}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <Typography gutterBottom>Gender</Typography>
              <ToggleButtonGroup
                value={formData.gender}
                exclusive
                onChange={(_, value) => value && setFormData(prev => ({ ...prev, gender: value }))}
              >
                <ToggleButton value="male">
                  <Male sx={{ mr: 1 }} /> Male
                </ToggleButton>
                <ToggleButton value="female">
                  <Female sx={{ mr: 1 }} /> Female
                </ToggleButton>
              </ToggleButtonGroup>
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControlLabel
                control={
                  <Switch
                    checked={formData.isActive}
                    onChange={e => setFormData(prev => ({ ...prev, isActive: e.target.checked }))}
                  />
                }
                label="Active Employee"
              />
            </Grid>
          </Grid>
        </Box>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button onClick={handleSubmit} variant="contained">
          {isEditing ? 'Update' : 'Add'} Employee
        </Button>
      </DialogActions>
    </Dialog>
  );
}

================
File: client/src/components/Layout.tsx
================
import React from 'react';
import { Outlet, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { Settings as SettingsIcon } from '@mui/icons-material';
import { Assessment as ReportsIcon } from '@mui/icons-material';

import {
  Box,
  Drawer,
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Typography,
  useTheme,
  Divider
} from '@mui/material';
import {
  Dashboard,
  People,
  AccessTime,
  Store as StoreIcon,
  Logout as LogoutIcon
} from '@mui/icons-material';

const DRAWER_WIDTH = 240;

const menuItems = [
  { text: 'Dashboard', Icon: Dashboard, path: '/' },
  { text: 'Employees', Icon: People, path: '/employees' },
  { text: 'Time Entries', Icon: AccessTime, path: '/time-entries' },
  { text: 'Shops', Icon: StoreIcon, path: '/shops' },
  { text: 'Settings', Icon: SettingsIcon, path: '/settings' },
  { text: 'Reports', Icon: ReportsIcon, path: '/reports' }
];

const Layout = () => {
  const navigate = useNavigate();
  const { logout } = useAuth();
  const theme = useTheme();

  return (
    <Box sx={{ display: 'flex' }}>
      <Drawer
        variant="permanent"
        sx={{
          width: DRAWER_WIDTH,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: DRAWER_WIDTH,
            boxSizing: 'border-box',
          },
        }}
      >
        <Toolbar sx={{ px: 2 }}>
          <Typography variant="h6" component="div" sx={{ color: 'white' }}>
            ZAFinance
          </Typography>
        </Toolbar>
        <Divider sx={{ borderColor: 'rgba(255, 255, 255, 0.12)' }} />
        <Box sx={{ overflow: 'auto' }}>
          <List>
            {menuItems.map((item) => (
              <ListItemButton
                key={item.text}
                onClick={() => navigate(item.path)}
                selected={window.location.pathname === item.path}
              >
                <ListItemIcon>
                  <item.Icon />
                </ListItemIcon>
                <ListItemText primary={item.text} />
              </ListItemButton>
            ))}
          </List>
          <Divider sx={{ borderColor: 'rgba(255, 255, 255, 0.12)' }} />
          <List>
            <ListItemButton onClick={logout}>
              <ListItemIcon>
                <LogoutIcon />
              </ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItemButton>
          </List>
        </Box>
      </Drawer>
      <Box
  component="main"
  sx={{
    flexGrow: 1,
    p: 4,  // Increased padding
    backgroundColor: theme.palette.background.default,
    minHeight: '100vh',
    width: `calc(100vw - ${DRAWER_WIDTH}px)` // Full width minus drawer
  }}
>
  <Outlet />
</Box>
    </Box>
  );
};

export default Layout;

================
File: client/src/components/QuickUploadButton.tsx
================
import React, { useRef, useState } from 'react';
import {
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Alert
} from '@mui/material';
import { CloudUpload, Close } from '@mui/icons-material';

interface QuickUploadButtonProps {
  employeeId: number;
  onUploadComplete?: () => void;
  size?: 'small' | 'medium' | 'large';
}

export default function QuickUploadButton({ employeeId, onUploadComplete, size = 'small' }: QuickUploadButtonProps) {
  const [open, setOpen] = useState(false);
  const [files, setFiles] = useState<File[]>([]);
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleUpload = async () => {
    if (!files.length) return;

    try {
      setUploading(true);
      const formData = new FormData();
      files.forEach(file => {
        formData.append('documents', file);
      });

      const token = localStorage.getItem('token');
      const response = await fetch(`/api/employees/${employeeId}/documents`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        },
        body: formData
      });

      if (!response.ok) throw new Error('Upload failed');

      setFiles([]);
      setOpen(false);
      if (onUploadComplete) onUploadComplete();
    } catch (error) {
      setError('Failed to upload files');
    } finally {
      setUploading(false);
    }
  };

  return (
    <>
      <IconButton onClick={() => setOpen(true)} size={size}>
        <CloudUpload />
      </IconButton>

      <Dialog open={open} onClose={() => !uploading && setOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Upload Documents</DialogTitle>
        <DialogContent>
          {error && (
            <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
              {error}
            </Alert>
          )}

          <Box
            sx={{
              border: '2px dashed',
              borderColor: 'divider',
              borderRadius: 1,
              p: 3,
              mb: 2,
              textAlign: 'center',
              cursor: 'pointer'
            }}
            onClick={() => fileInputRef.current?.click()}
          >
            <input
              type="file"
              ref={fileInputRef}
              hidden
              multiple
              onChange={(e) => e.target.files && setFiles(Array.from(e.target.files))}
            />
            <CloudUpload sx={{ fontSize: 40, color: 'primary.main', mb: 1 }} />
            <Typography>Drop files here or click to browse</Typography>
          </Box>

          {files.map((file, index) => (
            <Box
              key={index}
              sx={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                p: 1,
                mb: 1,
                bgcolor: 'background.paper',
                borderRadius: 1
              }}
            >
              <Typography noWrap>{file.name}</Typography>
              <IconButton
                size="small"
                onClick={() => setFiles(files.filter((_, i) => i !== index))}
                disabled={uploading}
              >
                <Close />
              </IconButton>
            </Box>
          ))}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)} disabled={uploading}>
            Cancel
          </Button>
          <Button
            onClick={handleUpload}
            variant="contained"
            disabled={uploading || !files.length}
          >
            {uploading ? 'Uploading...' : 'Upload'}
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
}

================
File: client/src/context/AuthContext.tsx
================
import React, { createContext, useState, useContext, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

interface AuthContextType {
  isAuthenticated: boolean;
  login: (token: string) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const navigate = useNavigate();

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      setIsAuthenticated(true);
    }
  }, []);

  const login = (token: string) => {
    localStorage.setItem('token', token);
    setIsAuthenticated(true);
  };

  const logout = () => {
    localStorage.removeItem('token');
    setIsAuthenticated(false);
    navigate('/login');
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: client/src/pages/Dashboard.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Grid,
  Paper,
  Typography,
  CircularProgress,
  Card,
  CardContent,
  IconButton,
  Link
} from '@mui/material';
import {
  People,
  Store,
  AccessTime,
  Visibility
} from '@mui/icons-material';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  LineChart,
  Line,
  Legend
} from 'recharts';
import { useNavigate } from 'react-router-dom';

interface DashboardStats {
  shops: {
    id: number;
    name: string;
    totalEmployees: number;
    clockedInEmployees: number;
    averageWage: number;
    monthlyHours: {
      date: string;
      hours: number;
      wages: number;
    }[];
  }[];
  overallStats: {
    totalShops: number;
    totalEmployees: number;
    clockedInEmployees: number;
    averageHourlyWage: number;
  };
  wageDistribution: {
    range: string;
    count: number;
  }[];
}

export default function Dashboard() {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchData = async () => {
      try {
        const token = localStorage.getItem('token');
        const response = await fetch('/api/dashboard', {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        const data = await response.json();
        setStats(data);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 60000); // Refresh every minute
    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="80vh">
        <CircularProgress />
      </Box>
    );
  }

  if (!stats) return null;

  return (
    <Box sx={{ p: 3 }}>
      {/* Overall Stats */}
      <Grid container spacing={3} mb={4}>
        <Grid item xs={12} md={3}>
          <Paper sx={{ p: 2, display: 'flex', alignItems: 'center', height: '100%' }}>
            <Store sx={{ fontSize: 40, color: 'primary.main', mr: 2 }} />
            <Box>
              <Typography variant="h4" fontWeight="bold">
                {stats.overallStats.totalShops}
              </Typography>
              <Typography color="textSecondary">Total Shops</Typography>
            </Box>
          </Paper>
        </Grid>

        <Grid item xs={12} md={3}>
          <Paper sx={{ p: 2, display: 'flex', alignItems: 'center', height: '100%' }}>
            <People sx={{ fontSize: 40, color: 'primary.main', mr: 2 }} />
            <Box>
              <Typography variant="h4" fontWeight="bold">
                {stats.overallStats.totalEmployees}
              </Typography>
              <Typography variant="body2" color="textSecondary">
                {stats.overallStats.clockedInEmployees} Currently Working
              </Typography>
            </Box>
          </Paper>
        </Grid>

        <Grid item xs={12} md={3}>
          <Paper sx={{ p: 2, display: 'flex', alignItems: 'center', height: '100%' }}>
            <AccessTime sx={{ fontSize: 40, color: 'primary.main', mr: 2 }} />
            <Box>
              <Typography variant="h4" fontWeight="bold">
                R{stats.overallStats.averageHourlyWage}
              </Typography>
              <Typography color="textSecondary">Avg. Hourly Rate</Typography>
            </Box>
          </Paper>
        </Grid>
      </Grid>

      {/* Wage Distribution Chart */}
      <Grid container spacing={3} mb={4}>
        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>Wage Distribution</Typography>
            <Box sx={{ height: 300 }}>
              <ResponsiveContainer>
                <BarChart data={stats.wageDistribution}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="range" />
                  <YAxis />
                  <Tooltip />
                  <Bar dataKey="count" fill="#8884d8" />
                </BarChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>
      </Grid>

      {/* Shop Cards */}
      <Grid container spacing={3}>
        {stats.shops.map((shop) => (
          <Grid item xs={12} md={4} key={shop.id}>
            <Card>
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                  <Typography variant="h6" gutterBottom>
                    {shop.name}
                  </Typography>
                  <IconButton
                    size="small"
                    onClick={() => navigate(`/shops/${shop.id}`)}
                  >
                    <Visibility />
                  </IconButton>
                </Box>

                <Typography variant="body2" color="textSecondary" gutterBottom>
                  Employees: {shop.clockedInEmployees}/{shop.totalEmployees} Active
                </Typography>

                <Typography variant="body2" color="textSecondary" gutterBottom>
                  Avg. Wage: R{shop.averageWage}/hr
                </Typography>

                <Box sx={{ height: 200, mt: 2 }}>
                  <ResponsiveContainer>
                    <LineChart data={shop.monthlyHours}>
                      <XAxis dataKey="date" />
                      <YAxis />
                      <Tooltip />
                      <Line type="monotone" dataKey="hours" stroke="#8884d8" />
                      <Line type="monotone" dataKey="wages" stroke="#82ca9d" />
                    </LineChart>
                  </ResponsiveContainer>
                </Box>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
}

================
File: client/src/pages/Employees.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  IconButton,
  TextField,
  InputAdornment
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Store,
  Search as SearchIcon
} from '@mui/icons-material';
import QuickUploadButton from '../components/QuickUploadButton';
import AssignShopDialog from '../components/AssignShopDialog';
import EmployeeDialog from '../components/EmployeeDialog.tsx';

interface Employee {
  id: number;
  name: string;
  surname: string;
  email: string;
  cellNumber: string;
  idNumber: string;
  gender: 'male' | 'female';
  hourlyRate: number;
  isActive: boolean;
  shopId?: number;
  documents?: string[];
  additionalFields?: Record<string, string>;
}

interface FormData {
  name: string;
  surname: string;
  cellNumber: string;
  email: string;
  idNumber: string;
  gender: 'male' | 'female';
  hourlyRate: number;
  isActive: boolean;
  shopId?: number;
  documents: File[];
  additionalFields: Record<string, string>;
}

export default function Employees() {
  // State declarations
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [filteredEmployees, setFilteredEmployees] = useState<Employee[]>([]);
  const [loading, setLoading] = useState(true);
  const [open, setOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [assignShopOpen, setAssignShopOpen] = useState(false);
const [selectedEmployee, setSelectedEmployee] = useState<Employee | null>(null);
  const [editingEmployee, setEditingEmployee] = useState<Employee | null>(null);
  const [formErrors, setFormErrors] = useState<Record<string, string>>({});

  const initialFormData: FormData = {
    name: '',
    surname: '',
    cellNumber: '',
    email: '',
    idNumber: '',
    gender: 'male',
    hourlyRate: 0,
    isActive: true,
    documents: [],
    additionalFields: {}
  };

  const [formData, setFormData] = useState<FormData>(initialFormData);

  useEffect(() => {
    fetchEmployees();
  }, []);

  const fetchEmployees = async () => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch('/api/employees', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) throw new Error('Failed to fetch employees');

      const data = await response.json();
      setEmployees(data);
      setFilteredEmployees(data);
    } catch (error) {
      console.error('Failed to fetch employees:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleEdit = (employee: Employee) => {
    setEditingEmployee(employee);
    setFormData({
      name: employee.name,
      surname: employee.surname,
      email: employee.email,
      cellNumber: employee.cellNumber,
      idNumber: employee.idNumber,
      gender: employee.gender,
      hourlyRate: employee.hourlyRate,
      isActive: employee.isActive,
      documents: [],
      additionalFields: employee.additionalFields || {}
    });
    setOpen(true);
  };

  const handleSubmit = async () => {
    if (!validateForm()) return;

    try {
      setSaving(true);
      const token = localStorage.getItem('token');
      const url = editingEmployee
        ? `/api/employees/${editingEmployee.id}`
        : '/api/employees';

      const formDataToSend = new FormData();
      Object.entries(formData).forEach(([key, value]) => {
        if (key !== 'documents' && key !== 'additionalFields') {
          formDataToSend.append(key, value.toString());
        }
      });

      if (formData.additionalFields) {
        formDataToSend.append('additionalFields', JSON.stringify(formData.additionalFields));
      }

      formData.documents.forEach(doc => {
        formDataToSend.append('documents', doc);
      });

      const response = await fetch(url, {
        method: editingEmployee ? 'PUT' : 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        },
        body: formDataToSend
      });

      if (!response.ok) {
        throw new Error('Failed to save employee');
      }

      await fetchEmployees();
      setOpen(false);
      setEditingEmployee(null);
      setFormData(initialFormData);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to save employee');
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = async (id: number) => {
    if (!window.confirm('Are you sure you want to delete this employee?')) return;

    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`/api/employees/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) throw new Error('Failed to delete employee');

      await fetchEmployees();
    } catch (error) {
      console.error('Failed to delete employee:', error);
    }
  };

  return (
    <Box sx={{ width: '100%', p: 3 }}>
      <Box sx={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        mb: 3
      }}>
        <Typography variant="h5" fontWeight={500}>
          Employees
        </Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => {
            setEditingEmployee(null);
            setFormData(initialFormData);
            setOpen(true);
          }}
        >
          Add Employee
        </Button>
      </Box>

      <Box sx={{ mb: 3 }}>
        <TextField
          size="small"
          placeholder="Search employees..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
          sx={{ width: 300 }}
        />
      </Box>

      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Name</TableCell>
              <TableCell>Email</TableCell>
              <TableCell>Phone</TableCell>
              <TableCell>Rate (ZAR)</TableCell>
              <TableCell>Status</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell colSpan={6} align="center">Loading...</TableCell>
              </TableRow>
            ) : employees.length === 0 ? (
              <TableRow>
                <TableCell colSpan={6} align="center">No employees found</TableCell>
              </TableRow>
            ) : (
              filteredEmployees.map((employee) => (
                <TableRow key={employee.id}>
                  <TableCell>{`${employee.name} ${employee.surname}`}</TableCell>
                  <TableCell>{employee.email}</TableCell>
                  <TableCell>{employee.cellNumber}</TableCell>
                  <TableCell>R{employee.hourlyRate.toFixed(2)}</TableCell>
                  <TableCell>
                    <Box
                      sx={{
                        bgcolor: employee.isActive ? 'success.light' : 'error.light',
                        color: employee.isActive ? 'success.dark' : 'error.dark',
                        px: 1,
                        py: 0.5,
                        borderRadius: 1,
                        display: 'inline-block',
                      }}
                    >
                      {employee.isActive ? 'Active' : 'Inactive'}
                    </Box>
                  </TableCell>
                  <TableCell>
                    <IconButton
                      size="small"
                      onClick={() => handleEdit(employee)}
                      sx={{ mr: 1 }}
                    >
                      <EditIcon />
                    </IconButton>

                    <QuickUploadButton
                      employeeId={employee.id}
                      onUploadComplete={fetchEmployees}
                      size="small"
                    />

<IconButton
  size="small"
  onClick={() => {
    setSelectedEmployee(employee);
    setAssignShopOpen(true);
  }}
  sx={{ mr: 1 }}
>
  <Store />
</IconButton>

                    <IconButton
                      size="small"
                      color="error"
                      onClick={() => handleDelete(employee.id)}
                    >
                      <DeleteIcon />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>

      {selectedEmployee && (
        <AssignShopDialog
          open={assignShopOpen}
          onClose={() => {
            setAssignShopOpen(false);
            setSelectedEmployee(null);
          }}
          employeeId={selectedEmployee.id}
          currentShopId={selectedEmployee.shopId}
          onAssigned={fetchEmployees}
        />
      )}
      <EmployeeDialog
  open={open}
  onClose={() => {
    setOpen(false);
    setEditingEmployee(null);
  }}
  onSubmit={async (formData) => {
    try {
      const token = localStorage.getItem('token');
      const url = editingEmployee
        ? `/api/employees/${editingEmployee.id}`
        : '/api/employees';

      const response = await fetch(url, {
        method: editingEmployee ? 'PUT' : 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
      });

      if (!response.ok) throw new Error('Failed to save employee');

      setOpen(false);
      setEditingEmployee(null);
      fetchEmployees();
    } catch (error) {
      console.error('Failed to save employee:', error);
    }
  }}
  initialData={editingEmployee ? {
    name: editingEmployee.name,
    surname: editingEmployee.surname,
    email: editingEmployee.email,
    cellNumber: editingEmployee.cellNumber,
    idNumber: editingEmployee.idNumber,
    gender: editingEmployee.gender,
    hourlyRate: editingEmployee.hourlyRate,
    isActive: editingEmployee.isActive
  } : undefined}
  isEditing={!!editingEmployee}
/>
    </Box>
  );
  {selectedEmployee && (
    <AssignShopDialog
      open={assignShopOpen}
      onClose={() => {
        setAssignShopOpen(false);
        setSelectedEmployee(null);
      }}
      employeeId={selectedEmployee.id}
      currentShopId={selectedEmployee.shopId}
      onAssigned={fetchEmployees}
    />
  )}
}

================
File: client/src/pages/Login.tsx
================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, Card, CardContent, TextField, Button, Typography, Alert } from '@mui/material';
import { useAuth } from '../context/AuthContext';

export default function Login() {
  const [credentials, setCredentials] = useState({ email: '', password: '' });
  const [error, setError] = useState('');
  const navigate = useNavigate();
  const { login } = useAuth();

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
        credentials: 'include'
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || 'Login failed');
      }

      const data = await res.json();
      login(data.token);
      navigate('/');
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Login failed');
      console.error('Login error:', error);
    }
  };

  return (
    <Box sx={{ height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', bgcolor: 'grey.100' }}>
      <Card sx={{ minWidth: 300, maxWidth: 400, width: '100%', m: 2 }}>
        <CardContent sx={{ p: 3 }}>
          <Typography variant="h5" gutterBottom align="center">
            ZAFinance Login
          </Typography>
          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}
          <form onSubmit={handleLogin}>
            <TextField
              fullWidth
              margin="normal"
              label="Email"
              type="email"
              required
              value={credentials.email}
              onChange={e => setCredentials({ ...credentials, email: e.target.value })}
            />
            <TextField
              fullWidth
              margin="normal"
              label="Password"
              type="password"
              required
              value={credentials.password}
              onChange={e => setCredentials({ ...credentials, password: e.target.value })}
            />
            <Button
              fullWidth
              type="submit"
              variant="contained"
              sx={{ mt: 3 }}
            >
              Login
            </Button>
          </form>
        </CardContent>
      </Card>
    </Box>
  );
}

================
File: client/src/pages/Reports.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
  Alert,
  CircularProgress,
  TableContainer,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format } from 'date-fns';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import PictureAsPdfIcon from '@mui/icons-material/PictureAsPdf';

interface Shop {
  id: number;
  name: string;
}

interface Employee {
  id: number;
  name: string;
  surname: string;
}

interface ReportFilters {
  startDate: Date;
  endDate: Date;
  shopId?: number;
  employeeId?: number;
  reportType: 'payroll' | 'attendance' | 'overtime';
}

export default function Reports() {
  const [filters, setFilters] = useState<ReportFilters>({
    startDate: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
    endDate: new Date(),
    reportType: 'payroll'
  });

  const [shops, setShops] = useState<Shop[]>([]);
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [reportData, setReportData] = useState<any>(null);

  useEffect(() => {
    fetchShopsAndEmployees();
  }, []);

  const fetchShopsAndEmployees = async () => {
    try {
      const token = localStorage.getItem('token');
      const [shopsRes, employeesRes] = await Promise.all([
        fetch('/api/shops', {
          headers: { 'Authorization': `Bearer ${token}` }
        }),
        fetch('/api/employees', {
          headers: { 'Authorization': `Bearer ${token}` }
        })
      ]);

      if (!shopsRes.ok || !employeesRes.ok) {
        throw new Error('Failed to fetch data');
      }

      const shopsData = await shopsRes.json();
      const employeesData = await employeesRes.json();

      setShops(shopsData);
      setEmployees(employeesData);
    } catch (error) {
      setError('Failed to load setup data');
    }
  };

  const generateReport = async () => {
    try {
      setLoading(true);
      setError(null);

      const token = localStorage.getItem('token');
      const response = await fetch('/api/reports', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          ...filters,
          startDate: format(filters.startDate, 'yyyy-MM-dd'),
          endDate: format(filters.endDate, 'yyyy-MM-dd')
        })
      });

      if (!response.ok) throw new Error('Failed to generate report');

      const data = await response.json();
      setReportData(data);
    } catch (error) {
      setError('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  const downloadReport = async (format: 'pdf' | 'excel') => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch('/api/reports/download', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          ...filters,
          startDate: format(filters.startDate, 'yyyy-MM-dd'),
          endDate: format(filters.endDate, 'yyyy-MM-dd'),
          format
        })
      });

      if (!response.ok) throw new Error('Failed to download report');

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `report-${filters.reportType}-${format(new Date(), 'yyyy-MM-dd')}.${format}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      setError('Failed to download report');
    }
  };

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h5" fontWeight={500} gutterBottom>
        Reports
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      <Paper sx={{ p: 3, mb: 3 }}>
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <FormControl fullWidth>
              <InputLabel>Report Type</InputLabel>
              <Select
                value={filters.reportType}
                label="Report Type"
                onChange={(e) => setFilters({
                  ...filters,
                  reportType: e.target.value as ReportFilters['reportType']
                })}
              >
                <MenuItem value="payroll">Payroll Report</MenuItem>
                <MenuItem value="attendance">Attendance Report</MenuItem>
                <MenuItem value="overtime">Overtime Report</MenuItem>
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} md={6}>
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <DatePicker
                label="Start Date"
                value={filters.startDate}
                onChange={(date) => date && setFilters({
                  ...filters,
                  startDate: date
                })}
                slotProps={{ textField: { fullWidth: true } }}
              />
            </LocalizationProvider>
          </Grid>

          <Grid item xs={12} md={6}>
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <DatePicker
                label="End Date"
                value={filters.endDate}
                onChange={(date) => date && setFilters({
                  ...filters,
                  endDate: date
                })}
                slotProps={{ textField: { fullWidth: true } }}
              />
            </LocalizationProvider>
          </Grid>

          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>Shop</InputLabel>
              <Select
                value={filters.shopId || ''}
                label="Shop"
                onChange={(e) => setFilters({
                  ...filters,
                  shopId: e.target.value as number
                })}
              >
                <MenuItem value="">All Shops</MenuItem>
                {shops.map((shop) => (
                  <MenuItem key={shop.id} value={shop.id}>
                    {shop.name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel>Employee</InputLabel>
              <Select
                value={filters.employeeId || ''}
                label="Employee"
                onChange={(e) => setFilters({
                  ...filters,
                  employeeId: e.target.value as number
                })}
              >
                <MenuItem value="">All Employees</MenuItem>
                {employees.map((emp) => (
                  <MenuItem key={emp.id} value={emp.id}>
                    {`${emp.name} ${emp.surname}`}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12}>
            <Box sx={{ display: 'flex', gap: 2, justifyContent: 'space-between' }}>
              <Button
                variant="contained"
                onClick={generateReport}
                disabled={loading}
              >
                Generate Report
              </Button>
              <Box sx={{ display: 'flex', gap: 1 }}>
                <Button
                  variant="outlined"
                  startIcon={<FileDownloadIcon />}
                  onClick={() => downloadReport('excel')}
                  disabled={!reportData || loading}
                >
                  Excel
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<PictureAsPdfIcon />}
                  onClick={() => downloadReport('pdf')}
                  disabled={!reportData || loading}
                >
                  PDF
                </Button>
              </Box>
            </Box>
          </Grid>
        </Grid>
      </Paper>

      {loading ? (
        <Box display="flex" justifyContent="center" p={3}>
          <CircularProgress />
        </Box>
      ) : reportData ? (
        <Paper sx={{ p: 3 }}>
          <TableContainer>
            <Typography variant="h6" gutterBottom>
              Report Results
            </Typography>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Employee</TableCell>
                  <TableCell align="right">Regular Hours</TableCell>
                  <TableCell align="right">Overtime Hours</TableCell>
                  <TableCell align="right">Total Pay</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {reportData.employees?.map((row: any) => (
                  <TableRow key={row.id}>
                    <TableCell>{row.name}</TableCell>
                    <TableCell align="right">{row.regularHours?.toFixed(2)}</TableCell>
                    <TableCell align="right">{row.overtimeHours?.toFixed(2)}</TableCell>
                    <TableCell align="right">R{row.totalPay?.toFixed(2)}</TableCell>
                  </TableRow>
                ))}
                {reportData.totals && (
                  <TableRow>
                    <TableCell><strong>Totals</strong></TableCell>
                    <TableCell align="right"><strong>{reportData.totals.regularHours?.toFixed(2)}</strong></TableCell>
                    <TableCell align="right"><strong>{reportData.totals.overtimeHours?.toFixed(2)}</strong></TableCell>
                    <TableCell align="right"><strong>R{reportData.totals.totalPay?.toFixed(2)}</strong></TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </TableContainer>
        </Paper>
      ) : null}
    </Box>
  );
}

================
File: client/src/pages/Settings.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  TextField,
  Button,
  Alert,
  Divider,
  CircularProgress,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { TimePicker } from '@mui/x-date-pickers/TimePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { parseISO, format } from 'date-fns';
import { Save as SaveIcon, RestartAlt as ResetIcon } from '@mui/icons-material';

interface Settings {
  id?: number;
  payrollStartDay: number;
  payrollEndDay: number;
  workDayStartTime: string;
  workDayEndTime: string;
  overtimeRate: number;
  weekendRate: number;
  holidayRate: number;
  holidays: Array<{ date: string; name: string; }>;
}

const defaultSettings: Settings = {
  payrollStartDay: 25,
  payrollEndDay: 24,
  workDayStartTime: '08:00',
  workDayEndTime: '17:00',
  overtimeRate: 1.5,
  weekendRate: 2.0,
  holidayRate: 2.5,
  holidays: [
    { date: '2024-01-01', name: "New Year's Day" },
    { date: '2024-03-21', name: 'Human Rights Day' },
    { date: '2024-04-19', name: 'Good Friday' },
    { date: '2024-04-22', name: 'Family Day' },
    { date: '2024-04-27', name: 'Freedom Day' },
    { date: '2024-05-01', name: 'Workers Day' },
    { date: '2024-06-16', name: 'Youth Day' },
    { date: '2024-08-09', name: "National Women's Day" },
    { date: '2024-09-24', name: 'Heritage Day' },
    { date: '2024-12-16', name: 'Day of Reconciliation' },
    { date: '2024-12-25', name: 'Christmas Day' },
    { date: '2024-12-26', name: 'Day of Goodwill' }
  ]
};

export default function Settings() {
  const [settings, setSettings] = useState<Settings | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  useEffect(() => {
    fetchSettings();
  }, []);

  const fetchSettings = async () => {
    try {
      setLoading(true);
      setError(null);
      const token = localStorage.getItem('token');
      const response = await fetch('/api/settings', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        throw new Error('Failed to fetch settings');
      }

      const data = await response.json();
      setSettings(data || defaultSettings);
    } catch (error) {
      console.error('Settings fetch error:', error);
      setError('Failed to load settings');
      setSettings(defaultSettings); // Fallback to default settings
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    if (!settings) return;

    try {
      setSaving(true);
      setError(null);
      setSuccess(false);

      const token = localStorage.getItem('token');
      const response = await fetch('/api/settings', {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(settings)
      });

      if (!response.ok) {
        throw new Error('Failed to save settings');
      }

      setSuccess(true);
      await fetchSettings(); // Refresh settings after save
    } catch (error) {
      console.error('Save error:', error);
      setError('Failed to save settings');
    } finally {
      setSaving(false);
    }
  };

  const handleReset = () => {
    if (window.confirm('Are you sure you want to reset to default settings?')) {
      setSettings(defaultSettings);
    }
  };

  const handleTimeChange = (field: 'workDayStartTime' | 'workDayEndTime', value: Date | null) => {
    if (!settings || !value) return;

    setSettings({
      ...settings,
      [field]: format(value, 'HH:mm')
    });
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
        <CircularProgress />
      </Box>
    );
  }

  if (!settings) return null;

  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h5" fontWeight={500}>
          System Settings
        </Typography>
        <IconButton
          onClick={handleReset}
          title="Reset to defaults"
          color="primary"
        >
          <ResetIcon />
        </IconButton>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mb: 2 }} onClose={() => setSuccess(false)}>
          Settings saved successfully
        </Alert>
      )}

      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Payroll Settings
        </Typography>
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              label="Payroll Start Day"
              type="number"
              value={settings.payrollStartDay}
              onChange={(e) => setSettings({
                ...settings,
                payrollStartDay: Math.min(31, Math.max(1, parseInt(e.target.value) || 1))
              })}
              inputProps={{ min: 1, max: 31 }}
              helperText="Day of the month when payroll period starts"
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              label="Payroll End Day"
              type="number"
              value={settings.payrollEndDay}
              onChange={(e) => setSettings({
                ...settings,
                payrollEndDay: Math.min(31, Math.max(1, parseInt(e.target.value) || 1))
              })}
              inputProps={{ min: 1, max: 31 }}
              helperText="Day of the month when payroll period ends"
            />
          </Grid>
        </Grid>

        <Box sx={{ mt: 4, mb: 2 }}>
          <Divider />
        </Box>

        <Typography variant="h6" gutterBottom>
          Working Hours
        </Typography>
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <TimePicker
                label="Work Day Start Time"
                value={parseISO(`2023-01-01T${settings.workDayStartTime}`)}
                onChange={(newValue) => handleTimeChange('workDayStartTime', newValue)}
                slotProps={{
                  textField: {
                    fullWidth: true,
                    helperText: 'Start time of standard work day'
                  }
                }}
              />
            </LocalizationProvider>
          </Grid>
          <Grid item xs={12} md={6}>
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <TimePicker
                label="Work Day End Time"
                value={parseISO(`2023-01-01T${settings.workDayEndTime}`)}
                onChange={(newValue) => handleTimeChange('workDayEndTime', newValue)}
                slotProps={{
                  textField: {
                    fullWidth: true,
                    helperText: 'End time of standard work day'
                  }
                }}
              />
            </LocalizationProvider>
          </Grid>
        </Grid>

        <Box sx={{ mt: 4, mb: 2 }}>
          <Divider />
        </Box>

        <Typography variant="h6" gutterBottom>
          Rate Multipliers
        </Typography>
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <TextField
              fullWidth
              label="Overtime Rate"
              type="number"
              value={settings.overtimeRate}
              onChange={(e) => setSettings({
                ...settings,
                overtimeRate: Math.max(1, parseFloat(e.target.value) || 1)
              })}
              inputProps={{ min: 1, step: 0.1 }}
              helperText="Multiplier for overtime hours"
            />
          </Grid>
          <Grid item xs={12} md={4}>
            <TextField
              fullWidth
              label="Weekend Rate"
              type="number"
              value={settings.weekendRate}
              onChange={(e) => setSettings({
                ...settings,
                weekendRate: Math.max(1, parseFloat(e.target.value) || 1)
              })}
              inputProps={{ min: 1, step: 0.1 }}
              helperText="Multiplier for weekend hours"
            />
          </Grid>
          <Grid item xs={12} md={4}>
            <TextField
              fullWidth
              label="Holiday Rate"
              type="number"
              value={settings.holidayRate}
              onChange={(e) => setSettings({
                ...settings,
                holidayRate: Math.max(1, parseFloat(e.target.value) || 1)
              })}
              inputProps={{ min: 1, step: 0.1 }}
              helperText="Multiplier for public holiday hours"
            />
          </Grid>
        </Grid>
      </Paper>

      <Paper sx={{ p: 3 }}>
        <Typography variant="h6" gutterBottom>
          Public Holidays (2024)
        </Typography>
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Date</TableCell>
                <TableCell>Holiday</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {settings.holidays
                .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
                .map((holiday) => (
                  <TableRow key={holiday.date}>
                    <TableCell>
                      {format(parseISO(holiday.date), 'MMMM d, yyyy')}
                    </TableCell>
                    <TableCell>{holiday.name}</TableCell>
                  </TableRow>
                ))}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>

      <Box sx={{ mt: 3, display: 'flex', justifyContent: 'flex-end' }}>
        <Button
          variant="contained"
          onClick={handleSave}
          disabled={saving}
          startIcon={<SaveIcon />}
        >
          {saving ? 'Saving...' : 'Save Settings'}
        </Button>
      </Box>
    </Box>
  );
}

================
File: client/src/pages/Shops.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Alert,
  IconButton,
  Switch,
  FormControlLabel
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';

interface Employee {
  id: number;
  name: string;
  hourlyRate: number;
  isActive: boolean;
}

interface Shop {
  id: number;
  name: string;
  address: string;
  employeeCount: number;
  isActive: boolean;
  employees?: Employee[];
}

interface FormData {
  name: string;
  address: string;
  isActive: boolean;
}

const initialFormData: FormData = {
  name: '',
  address: '',
  isActive: true
};

export default function Shops() {
  const [shops, setShops] = useState<Shop[]>([]);
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [editingShop, setEditingShop] = useState<Shop | null>(null);
  const [formData, setFormData] = useState<FormData>(initialFormData);

  useEffect(() => {
    fetchShops();
  }, []);

  const fetchShops = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('token');

      if (!token) {
        throw new Error('No authentication token found');
      }

      const response = await fetch('/api/shops', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        if (response.status === 401) {
          window.location.href = '/login';
          return;
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setShops(data);
      setError(null);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to fetch shops');
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = async () => {
    try {
      if (!formData.name.trim()) {
        setError('Shop name is required');
        return;
      }

      const token = localStorage.getItem('token');
      if (!token) {
        throw new Error('No authentication token found');
      }

      const url = editingShop
        ? `/api/shops/${editingShop.id}`
        : '/api/shops';

      const response = await fetch(url, {
        method: editingShop ? 'PUT' : 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(formData)
      });

      if (!response.ok) {
        throw new Error('Failed to save shop');
      }

      setOpen(false);
      setEditingShop(null);
      setFormData(initialFormData);
      await fetchShops();
      setError(null);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to save shop');
    }
  };

  const handleEdit = (shop: Shop) => {
    setEditingShop(shop);
    setFormData({
      name: shop.name,
      address: shop.address || '',
      isActive: shop.isActive
    });
    setOpen(true);
  };

  const handleDelete = async (id: number) => {
    if (!window.confirm('Are you sure you want to delete this shop?')) {
      return;
    }

    try {
      const token = localStorage.getItem('token');
      if (!token) {
        throw new Error('No authentication token found');
      }

      const response = await fetch(`/api/shops/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error('Failed to delete shop');
      }

      await fetchShops();
      setError(null);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to delete shop');
    }
  };

  return (
    <Box sx={{ width: '100%' }}>
      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      <Box sx={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        mb: 4
      }}>
        <Typography variant="h5" fontWeight={500}>
          Shops
        </Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => {
            setEditingShop(null);
            setFormData(initialFormData);
            setOpen(true);
          }}
        >
          Add Shop
        </Button>
      </Box>

      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Name</TableCell>
              <TableCell>Address</TableCell>
              <TableCell>Employees</TableCell>
              <TableCell>Status</TableCell>
              <TableCell align="right">Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell colSpan={5} align="center">Loading...</TableCell>
              </TableRow>
            ) : shops.length === 0 ? (
              <TableRow>
                <TableCell colSpan={5} align="center">
                  No shops found. Add your first shop to get started.
                </TableCell>
              </TableRow>
            ) : (
              shops.map((shop) => (
                <TableRow key={shop.id}>
                  <TableCell>{shop.name}</TableCell>
                  <TableCell>{shop.address}</TableCell>
                  <TableCell>{shop.employeeCount || 0}</TableCell>
                  <TableCell>
                    <Box
                      sx={{
                        backgroundColor: shop.isActive ? 'success.light' : 'error.light',
                        color: shop.isActive ? 'success.dark' : 'error.dark',
                        px: 1,
                        py: 0.5,
                        borderRadius: 1,
                        display: 'inline-block',
                      }}
                    >
                      {shop.isActive ? 'Active' : 'Inactive'}
                    </Box>
                  </TableCell>
                  <TableCell align="right">
                    <IconButton
                      onClick={() => handleEdit(shop)}
                      size="small"
                      sx={{ mr: 1 }}
                    >
                      <EditIcon />
                    </IconButton>
                    <IconButton
                      onClick={() => handleDelete(shop.id)}
                      size="small"
                      color="error"
                    >
                      <DeleteIcon />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>

      <Dialog
        open={open}
        onClose={() => {
          setOpen(false);
          setEditingShop(null);
          setFormData(initialFormData);
        }}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>
          {editingShop ? 'Edit Shop' : 'Add New Shop'}
        </DialogTitle>
        <DialogContent>
          <Box sx={{ pt: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
            <TextField
              label="Shop Name"
              fullWidth
              required
              value={formData.name}
              onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            />
            <TextField
              label="Address"
              fullWidth
              multiline
              rows={3}
              value={formData.address}
              onChange={(e) => setFormData({ ...formData, address: e.target.value })}
            />
            <FormControlLabel
              control={
                <Switch
                  checked={formData.isActive}
                  onChange={(e) => setFormData({ ...formData, isActive: e.target.checked })}
                />
              }
              label="Active"
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => {
              setOpen(false);
              setEditingShop(null);
              setFormData(initialFormData);
            }}
          >
            Cancel
          </Button>
          <Button variant="contained" onClick={handleSubmit}>
            {editingShop ? 'Update' : 'Add'} Shop
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}

================
File: client/src/pages/TimeEntries.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert
} from '@mui/material';
import { Add as AddIcon, AccessTime } from '@mui/icons-material';
import { differenceInMinutes, formatDistanceToNow } from 'date-fns';

interface TimeEntry {
  id: number;
  employeeId: number;
  employeeName: string;
  clockIn: string;
  clockOut: string | null;
  earnings: number;
}

interface Employee {
  id: number;
  name: string;
  surname: string;
  isActive: boolean;
  hourlyRate: number;
}

export default function TimeEntries() {
  const [entries, setEntries] = useState<TimeEntry[]>([]);
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [selectedEmployee, setSelectedEmployee] = useState<number>(0);
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTimeEntries = async () => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch('/api/time-entries', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) throw new Error('Failed to fetch time entries');

      const data = await response.json();
      setEntries(data);
    } catch (error) {
      console.error('Failed to fetch time entries:', error);
    }
  };

  const fetchEmployees = async () => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch('/api/employees', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) throw new Error('Failed to fetch employees');

      const data = await response.json();
      setEmployees(data.filter((emp: Employee) => emp.isActive));
    } catch (error) {
      console.error('Failed to fetch employees:', error);
    }
  };

  useEffect(() => {
    Promise.all([fetchTimeEntries(), fetchEmployees()])
      .finally(() => setLoading(false));

    const interval = setInterval(fetchTimeEntries, 60000);
    return () => clearInterval(interval);
  }, []);

  const handleClockIn = async () => {
    try {
      if (!selectedEmployee) {
        setError('Please select an employee');
        return;
      }

      const token = localStorage.getItem('token');
      const response = await fetch('/api/time-entries', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ employeeId: selectedEmployee })
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to clock in');
      }

      await fetchTimeEntries();
      setOpen(false);
      setSelectedEmployee(0);
      setError(null);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to clock in');
    }
  };

  const handleClockOut = async (id: number) => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`/api/time-entries/${id}/clock-out`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to clock out');
      }

      await fetchTimeEntries();
      setError(null);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to clock out');
    }
  };

  const formatDuration = (clockIn: string, clockOut: string | null) => {
    const start = new Date(clockIn);
    const end = clockOut ? new Date(clockOut) : new Date();
    return formatDistanceToNow(start, { addSuffix: true });
  };

  const isAlreadyClockedIn = (employeeId: number) => {
    return entries.some(entry => entry.employeeId === employeeId && !entry.clockOut);
  };

  return (
    <Box sx={{ p: 3 }}>
      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      <Box sx={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        mb: 3
      }}>
        <Typography variant="h5" fontWeight="500">
          Time Entries
        </Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => setOpen(true)}
        >
          Clock In
        </Button>
      </Box>

      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Employee</TableCell>
              <TableCell>Clock In</TableCell>
              <TableCell>Clock Out</TableCell>
              <TableCell>Duration</TableCell>
              <TableCell>Earnings (ZAR)</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell colSpan={6} align="center">Loading...</TableCell>
              </TableRow>
            ) : entries.length === 0 ? (
              <TableRow>
                <TableCell colSpan={6} align="center">
                  No time entries found
                </TableCell>
              </TableRow>
            ) : (
              entries.map((entry) => (
                <TableRow key={entry.id}>
                  <TableCell>{entry.employeeName}</TableCell>
                  <TableCell>
                    {new Date(entry.clockIn).toLocaleString()}
                  </TableCell>
                  <TableCell>
                    {entry.clockOut ?
                      new Date(entry.clockOut).toLocaleString() :
                      'Currently Working'
                    }
                  </TableCell>
                  <TableCell>
                    {formatDuration(entry.clockIn, entry.clockOut)}
                  </TableCell>
                  <TableCell>
                    R{entry.earnings.toFixed(2)}
                  </TableCell>
                  <TableCell>
                    {!entry.clockOut && (
                      <Button
                        variant="contained"
                        size="small"
                        onClick={() => handleClockOut(entry.id)}
                        startIcon={<AccessTime />}
                      >
                        Clock Out
                      </Button>
                    )}
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>

      <Dialog open={open} onClose={() => setOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Clock In Employee</DialogTitle>
        <DialogContent>
          <FormControl fullWidth sx={{ mt: 2 }}>
            <InputLabel>Select Employee</InputLabel>
            <Select
              value={selectedEmployee}
              label="Select Employee"
              onChange={(e) => setSelectedEmployee(Number(e.target.value))}
            >
              <MenuItem value={0} disabled>
                Select an employee
              </MenuItem>
              {employees.map((employee) => (
                <MenuItem
                  key={employee.id}
                  value={employee.id}
                  disabled={isAlreadyClockedIn(employee.id)}
                >
                  {`${employee.name} ${employee.surname}`}
                  {isAlreadyClockedIn(employee.id) && ' (Already clocked in)'}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)}>
            Cancel
          </Button>
          <Button
            variant="contained"
            onClick={handleClockIn}
            disabled={!selectedEmployee}
          >
            Clock In
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}

================
File: client/src/routes/index.tsx
================
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import Layout from '../components/Layout';
import Dashboard from '../pages/Dashboard';
import Employees from '../pages/Employees';
import TimeEntries from '../pages/TimeEntries';
import Shops from '../pages/Shops';
import Settings from '../pages/Settings';
import Reports from '../pages/Reports';
import Login from '../pages/Login';

const PrivateRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const token = localStorage.getItem('token');
  return token ? <>{children}</> : <Navigate to="/login" />;
};

const AppRoutes = () => {
  return (
    <Routes>
      <Route path="/login" element={<Login />} />
      <Route
        path="/"
        element={
          <PrivateRoute>
            <Layout />
          </PrivateRoute>
        }
      >
        <Route index element={<Dashboard />} />
        <Route path="employees" element={<Employees />} />
        <Route path="time-entries" element={<TimeEntries />} />
        <Route path="shops" element={<Shops />} />
        <Route path="settings" element={<Settings />} />
        <Route path="reports" element={<Reports />} />
      </Route>
    </Routes>
  );
};

export default AppRoutes;

================
File: client/src/utils/api.ts
================
const handleResponse = async (response: Response) => {
    if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Network response was not ok');
    }
    return response.json();
};

export const fetchWithAuth = async (url: string, options: RequestInit = {}) => {
    const token = localStorage.getItem('token');

    const defaultHeaders = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
    };

    try {
        const response = await fetch(url, {
            ...options,
            headers: {
                ...defaultHeaders,
                ...options.headers
            }
        });
        return await handleResponse(response);
    } catch (error) {
        console.error('API Error:', error);
        throw error;
    }
};

================
File: client/src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: client/src/App.tsx
================
import React from 'react';
import { BrowserRouter } from 'react-router-dom';
import { createTheme, ThemeProvider, CssBaseline } from '@mui/material';
import { AuthProvider } from './context/AuthContext';
import AppRoutes from './routes'; // We'll create this

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  components: {
    MuiDrawer: {
      styleOverrides: {
        paper: {
          width: 240,
          backgroundColor: '#1a237e', // Dark blue sidebar
          color: 'white',
        }
      }
    },
    MuiListItemButton: {
      styleOverrides: {
        root: {
          '&:hover': {
            backgroundColor: 'rgba(255, 255, 255, 0.1)',
          },
          '&.Mui-selected': {
            backgroundColor: 'rgba(255, 255, 255, 0.15)',
          }
        }
      }
    },
    MuiListItemIcon: {
      styleOverrides: {
        root: {
          color: 'white',
        }
      }
    }
  }
});

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <BrowserRouter>
        <AuthProvider>
          <AppRoutes />
        </AuthProvider>
      </BrowserRouter>
    </ThemeProvider>
  );
}

export default App;

================
File: client/src/index.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: client/src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: client/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: client/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: client/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: client/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZA-Finance</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: client/package.json
================
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --port 5173",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.15.3",
    "@mui/material": "^5.15.3",
    "@mui/x-date-pickers": "^6.20.2",
    "@types/multer": "^1.4.12",
    "date-fns": "^2.30.0",
    "multer": "^1.4.5-lts.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.21.1",
    "recharts": "^2.10.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "typescript": "^5.2.2",
    "vite": "^5.0.8"
  }
}

================
File: client/README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

================
File: client/tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: client/tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: client/tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: client/vite.config.ts
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, '/api')
      }
    }
  }
});

================
File: server/src/entities/Employee.ts
================
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from "typeorm";
import { Shop } from "./Shop";

@Entity("employees")
export class Employee {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column()
    name!: string;

    @Column()
    surname!: string;

    @Column()
    email!: string;

    @Column()
    cellNumber!: string;

    @Column()
    idNumber!: string;

    @Column({ default: 'male' })
    gender!: string;

    @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
    hourlyRate!: number;

    @Column({ default: true })
    isActive!: boolean;

    @Column({ nullable: true })
    shopId?: number;

    @Column("simple-array", { nullable: true })
    documents?: string[];

    @Column("simple-json", { nullable: true })
    additionalFields?: Record<string, string>;

    @ManyToOne(() => Shop, shop => shop.employees, { nullable: true })
    shop?: Shop;
}

================
File: server/src/entities/Entity.ts
================
export type BaseEntity = {
    id: number;
    createdAt: Date;
    updatedAt: Date;
}

================
File: server/src/entities/Settings.ts
================
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity("settings")
export class Settings {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ type: 'int', default: 25 })
    payrollStartDay!: number;

    @Column({ type: 'int', default: 24 })
    payrollEndDay!: number;

    @Column({ type: 'varchar', default: '08:00' })
    workDayStartTime!: string;

    @Column({ type: 'varchar', default: '17:00' })
    workDayEndTime!: string;

    @Column({ type: 'decimal', precision: 3, scale: 1, default: 1.5 })
    overtimeRate!: number;

    @Column({ type: 'decimal', precision: 3, scale: 1, default: 2.0 })
    weekendRate!: number;

    @Column({ type: 'decimal', precision: 3, scale: 1, default: 2.5 })
    holidayRate!: number;

    @Column({ type: 'simple-json', nullable: true })
    holidays?: { date: string; name: string }[];
}

================
File: server/src/entities/Shop.ts
================
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from "typeorm";
import { Employee } from "./Employee";

@Entity("shops")
export class Shop {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column()
    name!: string;

    @Column({ nullable: true })
    address!: string;

    @Column({ default: true })
    isActive!: boolean;

    @OneToMany(() => Employee, employee => employee.shop)
    employees!: Employee[];
}

================
File: server/src/entities/TimeEntry.ts
================
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, CreateDateColumn } from "typeorm";
import { Employee } from "./Employee";

@Entity("time_entries")
export class TimeEntry {
    @PrimaryGeneratedColumn()
    id!: number;

    @ManyToOne(() => Employee, (employee) => employee.timeEntries, { eager: true })
    employee!: Employee;

    @CreateDateColumn()
    clockIn!: Date;

    @Column({ type: 'datetime', nullable: true })
    clockOut?: Date;

    @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
    earnings!: number;
}

================
File: server/src/entities/User.ts
================
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity("user")
export class User {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({ unique: true })
    email!: string;

    @Column()
    password!: string;

    @Column({ default: 'user' })
    role!: 'admin' | 'user';
}

================
File: server/src/middleware/auth.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface JwtPayload {
    userId: number;
    role: string;
}

declare global {
    namespace Express {
        interface Request {
            user?: JwtPayload;
        }
    }
}

export const auth = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const token = req.headers.authorization?.split(' ')[1];

        if (!token) {
            return res.status(401).json({ error: 'Authentication required' });
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret') as JwtPayload;
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(401).json({ error: 'Invalid token' });
    }
};

================
File: server/src/middleware/errorHandler.ts
================
import { Request, Response, NextFunction } from 'express';

export const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Something broke!' });
};

================
File: server/src/migrations/UpdateEmployeeSchema.ts
================
import { MigrationInterface, QueryRunner, TableColumn } from "typeorm";

export class UpdateEmployeeSchema1732528257138 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        // Add new columns with nullable true first
        await queryRunner.addColumns("employees", [
            new TableColumn({
                name: "surname",
                type: "varchar",
                isNullable: true,  // Important: Start as nullable
                default: "''"
            }),
            new TableColumn({
                name: "email",
                type: "varchar",
                isNullable: true,
                default: "''"
            }),
            new TableColumn({
                name: "cellNumber",
                type: "varchar",
                isNullable: true,
                default: "''"
            }),
            new TableColumn({
                name: "idNumber",
                type: "varchar",
                isNullable: true,
                default: "''"
            }),
            new TableColumn({
                name: "gender",
                type: "varchar",
                isNullable: true,
                default: "'male'"
            }),
            new TableColumn({
                name: "additionalFields",
                type: "text",
                isNullable: true,
            }),
            new TableColumn({
                name: "documents",
                type: "text",
                isNullable: true,
            })
        ]);

        // Update existing records with default values
        await queryRunner.query(`
            UPDATE employees
            SET surname = '',
                email = '',
                cellNumber = '',
                idNumber = '',
                gender = 'male',
                additionalFields = '{}',
                documents = '[]'
            WHERE surname IS NULL
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        // Drop columns in reverse order
        const columns = [
            "documents",
            "additionalFields",
            "gender",
            "idNumber",
            "cellNumber",
            "email",
            "surname"
        ];

        for (const column of columns) {
            if (await queryRunner.hasColumn("employees", column)) {
                await queryRunner.dropColumn("employees", column);
            }
        }
    }
}

================
File: server/src/routes/auth.ts
================
import { Router, Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { AppDataSource } from '../database';
import { User } from '../entities/User';

const router = Router();

router.post('/login', async (req: Request, res: Response) => {
    try {
        const { email, password } = req.body;
        const userRepository = AppDataSource.getRepository(User);
        const user = await userRepository.findOne({ where: { email } });

        if (!user) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        const token = jwt.sign(
            { userId: user.id, role: user.role },
            process.env.JWT_SECRET || 'default-secret',
            { expiresIn: process.env.JWT_EXPIRY || '24h' }
        );

        return res.status(200).json({ token });
    } catch (error) {
        console.error('Login error:', error);
        return res.status(500).json({ error: 'Server error' });
    }
});

export default router;

================
File: server/src/routes/dashboard.ts
================
import { Router } from 'express';
import { AppDataSource } from '../database';
import { Employee } from '../entities/Employee';
import { TimeEntry } from '../entities/TimeEntry';
import { Shop } from '../entities/Shop';
import { auth } from '../middleware/auth';
import { IsNull } from 'typeorm';

const router = Router();

router.get('/', auth, async (req, res) => {
    try {
        const [shops, employees, timeEntries] = await Promise.all([
            AppDataSource.getRepository(Shop).find(),
            AppDataSource.getRepository(Employee).find({ relations: ['shop'] }),
            AppDataSource.getRepository(TimeEntry).find({
                where: { clockOut: IsNull() },
                relations: ['employee']
            })
        ]);

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // Calculate shop statistics
        const shopStats = await Promise.all(shops.map(async (shop) => {
            const shopEmployees = employees.filter(emp => emp.shopId === shop.id);
            const clockedInEmployees = timeEntries.filter(entry =>
                shopEmployees.some(emp => emp.id === entry.employee.id)
            );

            // Get monthly hours using query builder
            const monthlyHours = await AppDataSource
                .createQueryBuilder()
                .select([
                    "DATE(timeEntry.clockIn) as date",
                    "COUNT(DISTINCT employee.id) as employeeCount",
                    "SUM(CASE WHEN timeEntry.clockOut IS NOT NULL THEN ROUND((julianday(timeEntry.clockOut) - julianday(timeEntry.clockIn)) * 24, 2) ELSE 0 END) as hours",
                    "SUM(timeEntry.earnings) as wages"
                ])
                .from(TimeEntry, "timeEntry")
                .leftJoin("timeEntry.employee", "employee")
                .where("employee.shopId = :shopId", { shopId: shop.id })
                .andWhere("timeEntry.clockIn >= :startDate", {
                    startDate: new Date(today.getFullYear(), today.getMonth() - 1, today.getDate())
                })
                .groupBy("DATE(timeEntry.clockIn)")
                .getRawMany();

            const averageWage = shopEmployees.length > 0
                ? Number((shopEmployees.reduce((sum, emp) => sum + emp.hourlyRate, 0) / shopEmployees.length).toFixed(2))
                : 0;

            return {
                id: shop.id,
                name: shop.name,
                totalEmployees: shopEmployees.length,
                clockedInEmployees: clockedInEmployees.length,
                averageWage,
                monthlyHours: monthlyHours.map(mh => ({
                    date: mh.date,
                    hours: Number(mh.hours) || 0,
                    wages: Number(mh.wages) || 0,
                    employeeCount: Number(mh.employeeCount)
                }))
            };
        }));

        // Calculate wage distribution
        const wageRanges = [
            { min: 0, max: 50, label: 'R0-R50' },
            { min: 50, max: 100, label: 'R50-R100' },
            { min: 100, max: 150, label: 'R100-R150' },
            { min: 150, max: 200, label: 'R150-R200' },
            { min: 200, max: null, label: 'R200+' }
        ];

        const wageDistribution = wageRanges.map(({ min, max, label }) => ({
            range: label,
            count: employees.filter(emp =>
                max ? (emp.hourlyRate >= min && emp.hourlyRate < max) : emp.hourlyRate >= min
            ).length
        }));

        // Calculate overall statistics
        const overallStats = {
            totalShops: shops.length,
            totalEmployees: employees.length,
            clockedInEmployees: timeEntries.length,
            averageHourlyWage: employees.length > 0
                ? Number((employees.reduce((sum, emp) => sum + emp.hourlyRate, 0) / employees.length).toFixed(2))
                : 0
        };

        res.json({
            shops: shopStats,
            overallStats,
            wageDistribution
        });

    } catch (error) {
        console.error('Dashboard error:', error);
        res.status(500).json({ error: 'Failed to fetch dashboard data' });
    }
});

export default router;

================
File: server/src/routes/employees.ts
================
import { Router, Request, Response } from 'express';
import { AppDataSource } from '../database';
import { Employee } from '../entities/Employee';
import { auth } from '../middleware/auth';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';

const router = Router();
const employeeRepo = AppDataSource.getRepository(Employee);

// Configure multer for file uploads
const storage = multer.diskStorage({
    destination: async function (req, file, cb) {
        const uploadDir = './uploads/documents';
        try {
            await fs.mkdir(uploadDir, { recursive: true });
            cb(null, uploadDir);
        } catch (error) {
            cb(error as Error, uploadDir);
        }
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({
    storage,
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
    fileFilter: (req, file, cb) => {
        const allowedTypes = /jpeg|jpg|png|pdf|doc|docx/;
        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
        const mimetype = allowedTypes.test(file.mimetype);
        if (extname && mimetype) {
            return cb(null, true);
        }
        cb(null, false);
    }
});

// Create new employee
router.post('/', auth, upload.array('documents'), async (req: Request, res: Response) => {
    try {
        const {
            name,
            surname,
            email,
            cellNumber,
            idNumber,
            gender,
            hourlyRate,
            isActive
        } = req.body;

        // Validate required fields
        if (!name || !surname || !email || !cellNumber || !idNumber) {
            return res.status(400).json({ error: 'Required fields are missing' });
        }

        const files = (req as any).files as Express.Multer.File[] || [];
        const documents = files.map(file => file.filename);

        const employee = employeeRepo.create({
            name,
            surname,
            email,
            cellNumber,
            idNumber,
            gender: gender || 'male',
            hourlyRate: parseFloat(hourlyRate) || 0,
            isActive: isActive !== undefined ? isActive : true,
            documents
        });

        const savedEmployee = await employeeRepo.save(employee);
        res.status(201).json(savedEmployee);
    } catch (error) {
        // Clean up uploaded files if employee creation fails
        const files = (req as any).files as Express.Multer.File[] || [];
        for (const file of files) {
            try {
                await fs.unlink(file.path);
            } catch (unlinkError) {
                console.error('Failed to delete file:', unlinkError);
            }
        }

        console.error('Failed to create employee:', error);
        res.status(500).json({
            error: 'Failed to create employee',
            details: error instanceof Error ? error.message : 'Unknown error'
        });
    }
});

// Get all employees
router.get('/', auth, async (_req: Request, res: Response) => {
    try {
        const employees = await employeeRepo.find({
            relations: ['shop'],
            order: { name: 'ASC' }
        });
        res.json(employees);
    } catch (error) {
        console.error('Failed to fetch employees:', error);
        res.status(500).json({ error: 'Failed to fetch employees' });
    }
});

// Update employee
router.put('/:id', auth, upload.array('documents'), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const employee = await employeeRepo.findOne({
        where: { id: parseInt(id) }
      });

      if (!employee) {
        return res.status(404).json({ error: 'Employee not found' });
      }

      const files = (req as any).files as Express.Multer.File[];
      const newDocuments = files?.map(file => file.filename) || [];

      const updatedEmployee = {
        ...employee,
        ...req.body,
        documents: [...(employee.documents || []), ...newDocuments],
        hourlyRate: parseFloat(req.body.hourlyRate),
        isActive: req.body.isActive === 'true',
        additionalFields: req.body.additionalFields ? JSON.parse(req.body.additionalFields) : {}
      };

      const savedEmployee = await employeeRepo.save(updatedEmployee);
      res.json(savedEmployee);
    } catch (error) {
      console.error('Update error:', error);
      res.status(500).json({ error: 'Failed to update employee' });
    }
  });

// Assign shop to employee
router.put('/:id/assign-shop', auth, async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { shopId } = req.body;

        const employee = await employeeRepo.findOne({ where: { id: parseInt(id) } });

        if (!employee) {
            return res.status(404).json({ error: 'Employee not found' });
        }

        employee.shopId = shopId || null;
        await employeeRepo.save(employee);

        res.json({ message: 'Shop assigned successfully' });
    } catch (error) {
        console.error('Failed to assign shop:', error);
        res.status(500).json({ error: 'Failed to assign shop' });
    }
});

// Delete employee
router.delete('/:id', auth, async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const employee = await employeeRepo.findOne({ where: { id: parseInt(id) } });

        if (!employee) {
            return res.status(404).json({ error: 'Employee not found' });
        }

        if (employee.documents) {
            for (const doc of employee.documents) {
                try {
                    await fs.unlink(path.join('./uploads/documents', doc));
                } catch (error) {
                    console.error('Failed to delete document:', error);
                }
            }
        }

        await employeeRepo.remove(employee);
        res.json({ message: 'Employee deleted successfully' });
    } catch (error) {
        console.error('Failed to delete employee:', error);
        res.status(500).json({ error: 'Failed to delete employee' });
    }
});

router.post('/:id/documents', auth, upload.array('documents'), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const employee = await employeeRepo.findOne({
        where: { id: parseInt(id) }
      });

      if (!employee) {
        return res.status(404).json({ error: 'Employee not found' });
      }

      const files = (req as any).files as Express.Multer.File[];
      if (!files?.length) {
        return res.status(400).json({ error: 'No files uploaded' });
      }

      const documents = files.map(file => file.filename);
      employee.documents = [...(employee.documents || []), ...documents];

      await employeeRepo.save(employee);

      res.json({
        message: 'Documents uploaded successfully',
        documents: employee.documents
      });
    } catch (error) {
      console.error('Upload error:', error);
      res.status(500).json({ error: 'Failed to upload documents' });
    }
  });

export default router;

================
File: server/src/routes/reports.ts
================
import { Router, Request, Response } from 'express';
import { AppDataSource } from '../database';
import { TimeEntry } from '../entities/TimeEntry';
import { Employee } from '../entities/Employee';
import { Settings } from '../entities/Settings';
import { Between } from 'typeorm';
import { auth } from '../middleware/auth';
import { startOfDay, endOfDay, isWeekend, differenceInHours, format, parseISO, differenceInDays } from 'date-fns';
import ExcelJS from 'exceljs';
import PDFDocument from 'pdfkit';
import type { default as PDFKit } from 'pdfkit';

const router = Router();

interface Holiday {
    date: string;
    name: string;
}

// Helper function to check if a date is a holiday
const isHoliday = (date: Date, holidays: Holiday[] = []) => {
    const dateStr = format(date, 'yyyy-MM-dd');
    return holidays.some(holiday => holiday.date === dateStr);
};

// Helper function to calculate hours based on settings
const calculateHours = async (entries: TimeEntry[], settings: Settings) => {
    const workStart = parseISO(`2000-01-01T${settings.workDayStartTime}`);
    const workEnd = parseISO(`2000-01-01T${settings.workDayEndTime}`);
    const standardHours = differenceInHours(workEnd, workStart);

    let regularHours = 0;
    let overtimeHours = 0;
    let weekendHours = 0;
    let holidayHours = 0;

    for (const entry of entries) {
        const clockIn = new Date(entry.clockIn);
        const clockOut = entry.clockOut ? new Date(entry.clockOut) : new Date();
        const totalHours = differenceInHours(clockOut, clockIn);

        if (isWeekend(clockIn)) {
            weekendHours += totalHours;
        } else if (settings.holidays && isHoliday(clockIn, settings.holidays)) {
            holidayHours += totalHours;
        } else {
            if (totalHours > standardHours) {
                regularHours += standardHours;
                overtimeHours += (totalHours - standardHours);
            } else {
                regularHours += totalHours;
            }
        }
    }

    return {
        regularHours,
        overtimeHours,
        weekendHours,
        holidayHours,
        totalHours: regularHours + overtimeHours + weekendHours + holidayHours
    };
};

// Generate Report Data
const generateReportData = async (filters: any) => {
    const { startDate, endDate, shopId, employeeId } = filters;
    const settings = await AppDataSource.getRepository(Settings).findOne({ where: { id: 1 } });

    if (!settings) {
        throw new Error('System settings not found');
    }

    const queryBuilder = AppDataSource
        .getRepository(TimeEntry)
        .createQueryBuilder('timeEntry')
        .leftJoinAndSelect('timeEntry.employee', 'employee')
        .where({
            clockIn: Between(
                startOfDay(new Date(startDate)),
                endOfDay(new Date(endDate))
            )
        });

    if (shopId) {
        queryBuilder.andWhere('employee.shopId = :shopId', { shopId });
    }

    if (employeeId) {
        queryBuilder.andWhere('employee.id = :employeeId', { employeeId });
    }

    const entries = await queryBuilder.getMany();

    const employeeEntries = entries.reduce((acc, entry) => {
        const empId = entry.employee.id;
        if (!acc[empId]) {
            acc[empId] = [];
        }
        acc[empId].push(entry);
        return acc;
    }, {} as Record<number, TimeEntry[]>);

    const employeeReports = await Promise.all(
        Object.entries(employeeEntries).map(async ([empId, entries]) => {
            const employee = entries[0].employee;
            const hours = await calculateHours(entries, settings);

            const regularPay = hours.regularHours * employee.hourlyRate;
            const overtimePay = hours.overtimeHours * employee.hourlyRate * settings.overtimeRate;
            const weekendPay = hours.weekendHours * employee.hourlyRate * settings.weekendRate;
            const holidayPay = hours.holidayHours * employee.hourlyRate * settings.holidayRate;

            const daysPresent = new Set(
                entries.map(e => format(new Date(e.clockIn), 'yyyy-MM-dd'))
            ).size;

            const totalDays = Math.ceil(
                differenceInDays(new Date(endDate), new Date(startDate))
            );

            const lateArrivals = entries.filter(entry => {
                const clockIn = new Date(entry.clockIn);
                const [hours, minutes] = settings.workDayStartTime.split(':');
                const workStart = new Date(clockIn.setHours(parseInt(hours), parseInt(minutes), 0, 0));
                return clockIn > workStart;
            }).length;

            return {
                id: Number(empId),
                name: `${employee.name} ${employee.surname}`,
                ...hours,
                regularPay,
                overtimePay,
                weekendPay,
                holidayPay,
                totalPay: regularPay + overtimePay + weekendPay + holidayPay,
                daysPresent,
                daysAbsent: Math.max(0, totalDays - daysPresent),
                lateArrivals
            };
        })
    );

    return employeeReports;
};

// Generate Report
router.post('/', auth, async (req: Request, res: Response) => {
    try {
        const reportData = await generateReportData(req.body);
        const totals = reportData.reduce((acc, curr) => ({
            regularHours: acc.regularHours + curr.regularHours,
            overtimeHours: acc.overtimeHours + curr.overtimeHours,
            weekendHours: acc.weekendHours + curr.weekendHours,
            holidayHours: acc.holidayHours + curr.holidayHours,
            totalHours: acc.totalHours + curr.totalHours,
            regularPay: acc.regularPay + curr.regularPay,
            overtimePay: acc.overtimePay + curr.overtimePay,
            weekendPay: acc.weekendPay + curr.weekendPay,
            holidayPay: acc.holidayPay + curr.holidayPay,
            totalPay: acc.totalPay + curr.totalPay
        }), {
            regularHours: 0,
            overtimeHours: 0,
            weekendHours: 0,
            holidayHours: 0,
            totalHours: 0,
            regularPay: 0,
            overtimePay: 0,
            weekendPay: 0,
            holidayPay: 0,
            totalPay: 0
        });

        res.json({
            period: { startDate: req.body.startDate, endDate: req.body.endDate },
            employees: reportData,
            totals
        });
    } catch (error) {
        console.error('Failed to generate report:', error);
        res.status(500).json({ error: 'Failed to generate report' });
    }
});

// Excel Report Generation
async function generateExcelReport(reportData: any, reportType: string, workbook: ExcelJS.Workbook) {
    const worksheet = workbook.addWorksheet(reportType.charAt(0).toUpperCase() + reportType.slice(1));

    if (reportType === 'payroll') {
        worksheet.columns = [
            { header: 'Employee', key: 'name', width: 30 },
            { header: 'Regular Hours', key: 'regularHours', width: 15 },
            { header: 'Overtime Hours', key: 'overtimeHours', width: 15 },
            { header: 'Regular Pay', key: 'regularPay', width: 15 },
            { header: 'Overtime Pay', key: 'overtimePay', width: 15 },
            { header: 'Total Pay', key: 'totalPay', width: 15 }
        ];
    } else if (reportType === 'attendance') {
        worksheet.columns = [
            { header: 'Employee', key: 'name', width: 30 },
            { header: 'Days Present', key: 'daysPresent', width: 15 },
            { header: 'Days Absent', key: 'daysAbsent', width: 15 },
            { header: 'Late Arrivals', key: 'lateArrivals', width: 15 },
            { header: 'Total Hours', key: 'totalHours', width: 15 }
        ];
    } else {
        worksheet.columns = [
            { header: 'Employee', key: 'name', width: 30 },
            { header: 'Regular Hours', key: 'regularHours', width: 15 },
            { header: 'Overtime Hours', key: 'overtimeHours', width: 15 },
            { header: 'Overtime Pay', key: 'overtimePay', width: 15 }
        ];
    }

    worksheet.getRow(1).font = { bold: true };
    worksheet.addRows(reportData.employees);
    worksheet.addRow({});
    worksheet.addRow({
        name: 'TOTALS',
        ...reportData.totals
    }).font = { bold: true };

    ['regularPay', 'overtimePay', 'totalPay'].forEach(col => {
        if (worksheet.getColumn(col)) {
            worksheet.getColumn(col).numFmt = 'R#,##0.00';
        }
    });
}

// PDF Report Generation
async function generatePDFReport(reportData: any, reportType: string, doc: PDFKit.PDFDocument) {
    doc.fontSize(16).text(`${reportType.toUpperCase()} REPORT`, { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(`Period: ${format(new Date(reportData.period.startDate), 'PP')} to ${format(new Date(reportData.period.endDate), 'PP')}`, { align: 'center' });
    doc.moveDown();

    const startY = 150;
    let currentY = startY;

    if (reportType === 'payroll') {
        reportData.employees.forEach((employee: any) => {
            if (currentY > 700) {
                doc.addPage();
                currentY = 50;
            }
            doc.fontSize(10)
               .text(employee.name, 50, currentY)
               .text(employee.regularHours.toFixed(2), 200, currentY)
               .text(employee.overtimeHours.toFixed(2), 300, currentY)
               .text(`R${employee.totalPay.toFixed(2)}`, 400, currentY);
            currentY += 20;
        });
    }

    // Add totals
    doc.moveDown()
       .fontSize(12)
       .text('TOTALS', { underline: true })
       .text(`Total Hours: ${reportData.totals.totalHours.toFixed(2)}`)
       .text(`Total Pay: R${reportData.totals.totalPay.toFixed(2)}`);
}

// Download Report
router.post('/download', auth, async (req: Request, res: Response) => {
    try {
        const { format, ...filters } = req.body;
        const reportData = await generateReportData(filters);

        if (format === 'excel') {
            const workbook = new ExcelJS.Workbook();
            await generateExcelReport(reportData, filters.reportType, workbook);

            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename=report-${filters.reportType}-${format(new Date(), 'yyyy-MM-dd')}.xlsx`);

            await workbook.xlsx.write(res);
        } else if (format === 'pdf') {
            const doc = new PDFDocument();
            res.setHeader('Content-Type', 'application/pdf');
            res.setHeader('Content-Disposition', `attachment; filename=report-${filters.reportType}-${format(new Date(), 'yyyy-MM-dd')}.pdf`);

            doc.pipe(res);
            await generatePDFReport(reportData, filters.reportType, doc);
            doc.end();
        }
    } catch (error) {
        console.error('Failed to download report:', error);
        res.status(500).json({ error: 'Failed to download report' });
    }
});

export default router;

================
File: server/src/routes/settings.ts
================
import { Router, Request, Response } from 'express';
import { AppDataSource } from '../database';
import { Settings } from '../entities/Settings';
import { auth } from '../middleware/auth';

const router = Router();
const settingsRepo = AppDataSource.getRepository(Settings);

// Get settings
router.get('/', auth, async (_req: Request, res: Response) => {
    try {
        let settings = await settingsRepo.findOne({ where: { id: 1 } });

        if (!settings) {
            // Create default settings if none exist
            settings = await settingsRepo.save(settingsRepo.create({
                payrollStartDay: 25,
                payrollEndDay: 24,
                workDayStartTime: '08:00',
                workDayEndTime: '17:00',
                overtimeRate: 1.5,
                weekendRate: 2.0,
                holidayRate: 2.5,
                holidays: [
                    { date: '2024-01-01', name: "New Year's Day" },
                    { date: '2024-03-21', name: 'Human Rights Day' },
                    { date: '2024-04-19', name: 'Good Friday' },
                    { date: '2024-04-22', name: 'Family Day' },
                    { date: '2024-04-27', name: 'Freedom Day' },
                    { date: '2024-05-01', name: 'Workers Day' },
                    { date: '2024-06-16', name: 'Youth Day' },
                    { date: '2024-08-09', name: 'National Women\'s Day' },
                    { date: '2024-09-24', name: 'Heritage Day' },
                    { date: '2024-12-16', name: 'Day of Reconciliation' },
                    { date: '2024-12-25', name: 'Christmas Day' },
                    { date: '2024-12-26', name: 'Day of Goodwill' }
                ]
            }));
        }

        res.json(settings);
    } catch (error) {
        console.error('Failed to fetch settings:', error);
        res.status(500).json({ error: 'Failed to fetch settings' });
    }
});

// Update settings
router.put('/', auth, async (req: Request, res: Response) => {
    try {
        let settings = await settingsRepo.findOne({ where: { id: 1 } });
        if (!settings) {
            settings = settingsRepo.create({});
        }

        // Validate payroll days
        if (req.body.payrollStartDay < 1 || req.body.payrollStartDay > 31) {
            return res.status(400).json({ error: 'Invalid payroll start day' });
        }
        if (req.body.payrollEndDay < 1 || req.body.payrollEndDay > 31) {
            return res.status(400).json({ error: 'Invalid payroll end day' });
        }

        // Validate rates
        if (req.body.overtimeRate < 1) {
            return res.status(400).json({ error: 'Overtime rate must be at least 1' });
        }
        if (req.body.weekendRate < 1) {
            return res.status(400).json({ error: 'Weekend rate must be at least 1' });
        }
        if (req.body.holidayRate < 1) {
            return res.status(400).json({ error: 'Holiday rate must be at least 1' });
        }

        // Validate time format
        const timeRegex = /^([0-1][0-9]|2[0-3]):[0-5][0-9]$/;
        if (!timeRegex.test(req.body.workDayStartTime) || !timeRegex.test(req.body.workDayEndTime)) {
            return res.status(400).json({ error: 'Invalid time format. Use HH:mm' });
        }

        Object.assign(settings, req.body);
        await settingsRepo.save(settings);

        res.json(settings);
    } catch (error) {
        console.error('Failed to update settings:', error);
        res.status(500).json({ error: 'Failed to update settings' });
    }
});

export default router;

================
File: server/src/routes/shops.ts
================
import { Router } from 'express';
import { Request, Response } from 'express';
import { AppDataSource } from '../database';
import { Shop } from '../entities/Shop';
import { auth } from '../middleware/auth';

const router = Router();
const shopRepository = AppDataSource.getRepository(Shop);

// Get all shops
router.get('/', auth, async (_req: Request, res: Response) => {
    try {
        const shops = await shopRepository
            .createQueryBuilder('shop')
            .leftJoinAndSelect('shop.employees', 'employee')
            .getMany();

        const shopsWithCount = shops.map(shop => ({
            id: shop.id,
            name: shop.name,
            address: shop.address,
            isActive: shop.isActive,
            employeeCount: shop.employees?.length || 0
        }));

        res.status(200).json(shopsWithCount);
    } catch (error) {
        console.error('Failed to fetch shops:', error);
        res.status(500).json({ error: 'Failed to fetch shops' });
    }
});

// Create shop
router.post('/', auth, async (req: Request, res: Response) => {
    try {
        const shop = shopRepository.create(req.body);
        const result = await shopRepository.save(shop);
        res.status(201).json(result);
    } catch (error) {
        res.status(500).json({ error: 'Failed to create shop' });
    }
});

// Update shop
router.put('/:id', auth, async (req: Request, res: Response) => {
    try {
        const shop = await shopRepository.findOne({
            where: { id: parseInt(req.params.id) }
        });

        if (!shop) {
            return res.status(404).json({ error: 'Shop not found' });
        }

        shopRepository.merge(shop, req.body);
        const result = await shopRepository.save(shop);
        res.status(200).json(result);
    } catch (error) {
        res.status(500).json({ error: 'Failed to update shop' });
    }
});

// Delete shop
router.delete('/:id', auth, async (req: Request, res: Response) => {
    try {
        const shop = await shopRepository.findOne({
            where: { id: parseInt(req.params.id) },
            relations: ['employees']
        });

        if (!shop) {
            return res.status(404).json({ error: 'Shop not found' });
        }

        if (shop.employees?.length > 0) {
            return res.status(400).json({ error: 'Cannot delete shop with employees' });
        }

        await shopRepository.remove(shop);
        res.status(200).json({ message: 'Shop deleted' });
    } catch (error) {
        res.status(500).json({ error: 'Failed to delete shop' });
    }
});

export default router;

================
File: server/src/routes/timeEntries.ts
================
import { Router } from 'express';
import { AppDataSource } from '../database';
import { TimeEntry } from '../entities/TimeEntry';
import { Employee } from '../entities/Employee';
import { auth } from '../middleware/auth';
import { IsNull } from 'typeorm';

const router = Router();
const timeEntryRepo = AppDataSource.getRepository(TimeEntry);
const employeeRepo = AppDataSource.getRepository(Employee);

// Get all time entries
router.get('/', auth, async (_req, res) => {
    try {
        const entries = await timeEntryRepo.find({
            relations: ['employee'],
            order: { clockIn: 'DESC' }
        });

        const formattedEntries = entries.map(entry => ({
            id: entry.id,
            employeeId: entry.employee.id,
            employeeName: `${entry.employee.name} ${entry.employee.surname}`,
            clockIn: entry.clockIn,
            clockOut: entry.clockOut,
            earnings: entry.earnings
        }));

        res.json(formattedEntries);
    } catch (error) {
        console.error('Failed to fetch time entries:', error);
        res.status(500).json({ error: 'Failed to fetch time entries' });
    }
});

// Clock in
router.post('/', auth, async (req, res) => {
    try {
        const { employeeId } = req.body;

        const employee = await employeeRepo.findOne({
            where: { id: employeeId }
        });

        if (!employee) {
            return res.status(404).json({ error: 'Employee not found' });
        }

        if (!employee.isActive) {
            return res.status(400).json({ error: 'Inactive employees cannot clock in' });
        }

        // Check if already clocked in
        const existingEntry = await timeEntryRepo.findOne({
            where: {
                employee: { id: employeeId },
                clockOut: IsNull()
            }
        });

        if (existingEntry) {
            return res.status(400).json({ error: 'Employee is already clocked in' });
        }

        const timeEntry = timeEntryRepo.create({
            employee,
            clockIn: new Date(),
            earnings: 0
        });

        await timeEntryRepo.save(timeEntry);
        res.status(201).json(timeEntry);
    } catch (error) {
        console.error('Failed to clock in:', error);
        res.status(500).json({ error: 'Failed to clock in' });
    }
});

// Clock out
router.put('/:id/clock-out', auth, async (req, res) => {
    try {
        const entry = await timeEntryRepo.findOne({
            where: { id: parseInt(req.params.id) },
            relations: ['employee']
        });

        if (!entry) {
            return res.status(404).json({ error: 'Time entry not found' });
        }

        if (entry.clockOut) {
            return res.status(400).json({ error: 'Already clocked out' });
        }

        entry.clockOut = new Date();

        // Calculate hours worked and earnings
        const hoursWorked =
            (entry.clockOut.getTime() - entry.clockIn.getTime()) / (1000 * 60 * 60);

        entry.earnings = hoursWorked * entry.employee.hourlyRate;

        await timeEntryRepo.save(entry);
        res.json(entry);
    } catch (error) {
        console.error('Failed to clock out:', error);
        res.status(500).json({ error: 'Failed to clock out' });
    }
});

export default router;

================
File: server/src/types/express/index.d.ts
================
import { User } from '../../entities/User';

declare global {
    namespace Express {
        interface Request {
            user?: {
                userId: number;
                role: string;
            }
        }
    }
}

export {};

================
File: server/src/types/custom.d.ts
================
declare namespace Express {
    export interface Request {
        user?: {
            userId: number;
            role: string;
        }
    }
}

================
File: server/src/app.ts
================
import 'reflect-metadata';
import express from 'express';
import cors from 'cors';
import { initializeDatabase } from './database';
import authRoutes from './routes/auth';
import employeeRoutes from './routes/employees';
import timeEntryRoutes from './routes/timeEntries';
import shopRoutes from './routes/shops';
import settingsRoutes from './routes/settings';
import dashboardRoutes from './routes/dashboard';
import reportsRoutes from './routes/reports';
import path from 'path';

const app = express();

// CORS Configuration
app.use(cors({
    origin: 'http://localhost:5173',
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization']
}));

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Static files
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/employees', employeeRoutes);
app.use('/api/time-entries', timeEntryRoutes);
app.use('/api/shops', shopRoutes);
app.use('/api/settings', settingsRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/reports', reportsRoutes);

// Error handling middleware
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Something went wrong!' });
});

const PORT = process.env.PORT || 5000;

const startServer = async () => {
    try {
        await initializeDatabase();
        app.listen(PORT, () => {
            console.log(`Server running on port ${PORT}`);
        });
    } catch (error) {
        console.error('Server startup failed:', error);
        process.exit(1);
    }
};

startServer();

export default app;

================
File: server/src/config.ts
================
import dotenv from 'dotenv';
import path from 'path';

dotenv.config();

export const config = {
    port: process.env.PORT || 5000,
    jwt: {
        secret: process.env.JWT_SECRET || 'default-secret-key',
        expiry: process.env.JWT_EXPIRY || '24h'
    },
    db: {
        path: process.env.DB_PATH || path.join(__dirname, '..', 'database.sqlite'),
        synchronize: process.env.NODE_ENV === 'development'
    },
    cors: {
        origin: process.env.FRONTEND_URL || 'http://localhost:5173'
    }
};

================
File: server/src/data-source.ts
================
import { DataSource } from "typeorm";
import { User } from "./entities/User";
import { Employee } from "./entities/Employee";
import { TimeEntry } from "./entities/TimeEntry";
import { Shop } from "./entities/Shop";
import { Settings } from "./entities/Settings";
import { config } from "./config";

export const AppDataSource = new DataSource({
    type: "sqlite",
    database: config.db.path,
    synchronize: config.db.synchronize,
    logging: true,
    entities: [User, Employee, TimeEntry, Shop, Settings],
    migrations: ["src/migrations/*.ts"]
});

================
File: server/src/database.ts
================
import { DataSource } from "typeorm";
import { User } from "./entities/User";
import { Employee } from "./entities/Employee";
import { TimeEntry } from "./entities/TimeEntry";
import { Shop } from "./entities/Shop";
import { Settings } from "./entities/Settings";
import path from "path";
import bcrypt from 'bcrypt';

export const AppDataSource = new DataSource({
    type: "sqlite",
    database: path.join(__dirname, "..", "database.sqlite"),
    synchronize: true,
    logging: true,
    entities: [User, Employee, TimeEntry, Shop, Settings],
    migrations: [path.join(__dirname, "migrations", "*.{ts,js}")],
});

export const initializeDatabase = async (): Promise<boolean> => {
    try {
        if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
            console.log("Database initialized successfully");

            // Check and create admin user
            const userRepo = AppDataSource.getRepository(User);
            let adminUser = await userRepo.findOne({
                where: { email: 'kevin@cybercorelabs.co.za' }
            });

            if (!adminUser) {
                const hashedPassword = await bcrypt.hash('990309@Kevin', 10);
                adminUser = userRepo.create({
                    email: 'kevin@cybercorelabs.co.za',
                    password: hashedPassword,
                    role: 'admin'
                });
                await userRepo.save(adminUser);
                console.log('Admin user created successfully');
            }
        }
        return true;
    } catch (error) {
        console.error("Database initialization error:", error);
        return false;
    }
};

================
File: server/package.json
================
{
  "name": "server",
  "version": "1.0.0",
  "main": "src/app.ts",
  "scripts": {
    "start": "node build/app.js",
    "dev": "nodemon --exec ts-node src/app.ts",
    "build": "tsc",
    "typeorm": "typeorm-ts-node-commonjs"
  },
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "date-fns": "^2.30.0",
    "dotenv": "^16.3.1",
    "exceljs": "^4.4.0",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "pdfkit": "^0.15.1",
    "reflect-metadata": "^0.1.13",
    "sqlite3": "^5.1.6",
    "typeorm": "^0.3.17"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/multer": "^1.4.12",
    "@types/node": "^20.17.8",
    "@types/pdfkit": "^0.13.6",
    "nodemon": "^3.0.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  }
}

================
File: server/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "lib": ["es6"],
    "allowJs": true,
    "outDir": "build",
    "rootDir": "src",
    "strict": true,
    "noImplicitAny": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "strictPropertyInitialization": false,
    "typeRoots": ["./src/types", "./node_modules/@types"],
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "build"]
}

================
File: server/typeorm.config.ts
================
import { DataSource } from "typeorm";
import { User } from "./src/entities/User";
import { Employee } from "./src/entities/Employee";
import { TimeEntry } from "./src/entities/TimeEntry";
import { Shop } from "./src/entities/Shop";
import path from "path";
import dotenv from "dotenv";

dotenv.config();

const dataSource = new DataSource({
    type: "sqlite",
    database: path.join(__dirname, "database.sqlite"),
    entities: [
        User,
        Employee,
        TimeEntry,
        Shop
    ],
    migrations: [path.join(__dirname, "src", "migrations", "*.{ts,js}")],
    synchronize: false,
    logging: true
});

export default dataSource;

================
File: .gitignore
================
# Dependencies
node_modules/
/.pnp
.pnp.js

# Testing
/coverage

# Production
/build
/dist

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
